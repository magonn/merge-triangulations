% !TEX encoding = UTF-8 Unicode
\documentclass[12pt]{article}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english, russian]{babel}

\usepackage{graphicx}
\graphicspath{{images/}}

\usepackage{amsmath, amsthm, amssymb, thmtools}

\usepackage{algorithmicx}
\usepackage[Algorithm,ruled]{algorithm}
\usepackage{algpseudocode}
\newcommand{\Break}{\State \textbf{break} }

\usepackage{cite}

\usepackage{geometry}
\usepackage{indentfirst}
\textheight = 24cm
\textwidth = 16cm
\oddsidemargin = 0cm
\topmargin = -1.5cm
\parindent = 24pt
\parskip = 0pt
\flushbottom
\linespread{1.3}

\declaretheorem[style = definition, numbered = no, name = Определение]{definition}
\declaretheorem[style = plain, name = Лемма]{lemma}
\declaretheorem[style = plain, name = Теорема]{theorem}

\begin{document}
\begin{titlepage}
\begin{center}

	\includegraphics[width=50mm]{msu.eps}
	
	\bigskip

	Московский государственный университет имени~М.~В.~Ломоносова\\
	Факультет Вычислительной Математики и Кибернетики\\
	Кафедра Математических Методов Прогнозирования\\[30mm]

	\textsf{\large
      ВЫПУСКНАЯ КВАЛИФИКАЦИОННАЯ РАБОТА\\[10mm]
      \textbf{
        Слияние перекрывающихся триангуляций Делоне на основе минимальных остовных деревьев
      }
    }\\[30mm]
	
	\begin{flushright}
      \parbox{0.5\textwidth}{
        \raggedleft
        \textbf{Выполнила:}\\
        студентка 417 группы\\
        Готман Мария Леонидовна\\[5mm]
        \textbf{Научный руководитель:}\\
        д.т.н., профессор\\
        Местецкий Леонид Моисеевич
      }
    \end{flushright}	
	
	\vspace{\fill}
	Москва, 2015
\end{center}
\end{titlepage}

\newpage

\tableofcontents

\newpage
\begin{abstract}
В данной работе рассмотрен алгоритм слияния двух триангуляций Делоне,
причем множества, на которых заданы исходные триангуляции, допускают полное перемешивание.
Метод, позволяющий решить данную задачу, имеет линейную сложность в худшем случае.
Он основан на построении минимальных остовных деревьев исходных триангуляций
при помощи алгоритма Черитона-Тарьяна.
Это является ключевой частью алгоритма, за счет чего достигается его линейная сложность.
\end{abstract}

\newpage
\section{Введение}
Рассматривается задача слияния двух триангуляций Делоне, линейная разделимость исходных облаков точек которых не предполагается.
Впервые задача построения триангуляции Делоне была рассмотрена в 1934 году российским математиком Борисом Делоне.
На практике триангуляции Делоне применяются во многих прикладных задачах:
сравнение 3D поверхностей, интерполяция разреженных геонаучных данных,
аппроксимация географических поверхностей на плоскости и т.д.

Несмотря на то, что построение триангуляции Делоне является распространенной задачей в вычислительной геометрии \cite{Skvortsov},
слияние неразделенных триангуляций исследовано мало.
Такую задачу решают обычно одним из следующих способов.
Первый способ основан на том, что информация об исходных триангуляциях никак не учитывается и искомая триангуляция строится
по объединенному множеству точек с нуля. Сложность такого алгоритма $O(n\log n)$ в худшем случае.
Такая асимптотика достигается при помощи парадигмы <<разделяй и властвуй>> \cite[стр. 44-45]{Skvortsov}.
Множество точек рекурсивно разделяется на два линейно разделимых подмножества.
Рекурсия прекращается, когда в подмножестве останется две или три точки
на которых строится тривиальная триангуляция в виде линии или треугольника соответственно.
Затем происходит процесс слияния разделенных триангуляций за линейное время.
Второй способ разрушает только одну триангуляцию,
затем последовательно добавляет по одной точке разрушенной триангуляции с помощью инкрементного алгоритма.
Такой подход имеет сложность $O(n^2)$ в худшем случае.

Как видно, оба подхода не используют всю информацию о исходных триангуляциях,
поэтому естественно кажется, что существует алгоритм, помогающий осуществить слияние за линейное время.
В данной работе рассматривается линейный алгоритм слияния триангуляций Делоне.
Алгоритм основан на построении минимальных остовных деревьев (МОД) исходных триангуляций
при помощи алгоритма Черитона-Тарьяна.
Известно, что МОД является подграфом триангуляции Делоне.
Эта информация используется при поиске новых ребер, соединяющих две исходные триангуляции.
Если найдено ребро, соединяющее точки из разных исходных триангуляций, называемое стартером,
то можно строить <<швы>>, соединяющие исходные триангуляции,
и <<разрезы>>, содержащие ребра исходных триангуляций, которые перестали удовлетворять условию Делоне.
Подзадача построения швов и разрезов является наиболее сложно осуществимой с технической точки зрения.
Поиск стартеров технически проще, но понимание его математического обоснования
требует должных усилий.

\section{Терминология и постановка задачи}

\subsection{Основные определения}
Пусть на евклидовой плоскости задано $\textbf{S}$ --- множество из не менее трех точек, не все из которых лежат на одной прямой.
Используя \cite[стр.~7-8]{Skvortsov}, \cite{MestOverlap}, введем ряд ключевых определений которые понадобятся нам для дальнейшего понимания задачи.

Точки, входящие во множество $\textbf{S}$, будем называть {\itshape сайтами}.
{\itshape Триангуляцией} конечного множества точек $\textbf{S}$ называется планарный граф с вершинами из $\textbf{S}$,
все внутренние области которого являются треугольниками.
Триангуляция называется {\itshape выпуклой}, если минимальный многоугольник, охватывающий все ее треугольники, будет выпуклым.
Далее под термином {\itshape грань} будем понимать только конечную треугольную грань триангуляции.
Ребро и грань называются {\itshape инцидентными}, если они имеют две общие вершины.
Ребра, инцидентные одной грани, называются {\itshape смежными}.
Ребро, имеющее менее двух инцидентных граней, называется {\itshape открытым}.

Окружность называется {\itshape пустой}, если она не содержит внутри себя сайтов.
Прямая линия, по одну сторону от которой нет сайтов, называется {\itshape несобственной} пустой окружностью.
Окружность, проходящая через сайт, называется {\itshape инцидентной} этому сайту.
{\itshape Ребром Делоне} называется ребро, инцидентные сайты которого имеют общую пустую инцидентную окружность.
{\itshape Гранью Делоне} называют грань, вершины которой имеют общую пустую инцидентную окружность.

Дадим два эквивалентных определения:

\begin{definition}
{\itshape Триангуляцией Делоне (ТД) $Del(\textbf{S})$} множества точек $\textbf{S}$ называется выпуклая триангуляция,
у которой описанная окружность каждой треугольной грани является пустой,
т.е. все грани которой являются гранями Делоне.
\end{definition}

\begin{definition}
{\itshape Триангуляцией Делоне} множества точек $\textbf{S}$ называется выпуклая триангуляция,
у которой для каждого ребра существует пустая инцидентная сайтам-вершинам окружность,
т.е. все ребра которой являются ребрами Делоне.
\end{definition}

{\itshape Пучком} сайта $p \in \textbf{S}$ называют множество ребер триангуляции, инцидентных сайту $p$.
Пучок сайтов будем представлять в виде двунаправленного циклического списка сайтов $p_1, \ldots, p_k$,
смежных с $p$ в триангуляции, так чтобы они шли в направлении обхода против часовой стрелки относительно $p$.

\subsection{Постановка задачи}
Задача слияния двух перекрывающихся триангуляций Делоне ставится следующим образом.
Даны два конечных линейно неразделимых множества сайтов $\textbf{B}$ и $\textbf{W}$ (допускается их полное перемешивание),
а также их триангуляции Делоне $Del(\textbf{B})$ и $Del(\textbf{W})$.
Нужно построить триангуляцию Делоне на объединенном множестве сайтов $Del(\textbf{B} \cup \textbf{W})$.

Будем считать, что сайты раскрашены в два цвета: множество черных сайтов $\textbf{B}$ и множество белых сайтов $\textbf{W}$.
Триангуляции множеств $\textbf{B}$ и $\textbf{W}$ будем называть исходными,
искомую триангуляцию $Del(\textbf{B} \cup \textbf{W})$ будем называть объединенной.
Пример исходных данных и искомой триангуляции приведен на рис. \ref{pic:model_data}.

\begin{figure}[htb!]
	\begin{minipage}[h]{0.49\linewidth}
		\center{\includegraphics[width=1\linewidth]{model_data.png}}
	\end{minipage}
	\hfill
	\begin{minipage}[h]{0.49\linewidth}
		\center{\includegraphics[width=1\linewidth]{model_res.png}}
	\end{minipage}
	\caption{Исходные триангуляции и объединенная триангуляция}
	\label{pic:model_data}
\end{figure}

Нижняя оценка для задачи построения триангуляции Делоне множества точек $\textbf{S}$ известна
и имеет сложность $O(n\log n)$, где $n = |\textbf{S}|$ \cite[лекции 10-11]{Lectures}.
Такую сложность имеет, например, алгоритм, основанный на парадигме <<разделяй и властвуй>> \cite[стр.44-45]{Skvortsov}.
Этот алгоритм имеет сложность $O(n\log n)$ в среднем и худшем случае.
Такой алгоритм позволяет производить слияние разделенных триангуляций Делоне за линейное по числу точек время.
Однако вопрос о слиянии перекрывающихся триангуляций Делоне остается открытым.
Возможным подходом является построение объединенной триангуляции на множестве $\textbf{B} \cup \textbf{W}$
без учета информации о исходных триангуляциях.
Такой подход не является эффективным.
В \cite{MestOverlap} доказана теоретическая оценка времени слияния неразделенных триангуляций Делоне, равная в худшем случае $O(n)$.
Ранее были попытки реализовать метод, описанный в \cite{MestOverlap},
но полностью линейный алгоритм так и не был реализован.

В настоящей работе будет описан линейный алгоритм слияния триангуляций Делоне,
показывающий правильность описанного в \cite{MestOverlap} метода,
а также проведены эксперименты, доказывающие его теоретическую оценку.

\section{Метод слияния триангуляций}
Используя терминологию, введенную в \cite{MestOverlap} определим несколько понятий.

В объединенной триангуляции Делоне $Del(\textbf{B} \cup \textbf{W})$ существуют ребра двух типов:
одноцветные, которые были взяты из исходных триангуляций, и разноцветные, сайты-вершины которых взяты из разных исходных триангуляций.

Множество вершин и ребер (ребер и граней) называется {\itshape связным}, если для любой пары элементов этого множества
существует цепь из попарно инцидентных вершин и ребер (ребер и граней), принадлежащих этому множеству.

В объединенной триангуляции существуют максимальные связные одноцветные подмножества вершин и ребер,
переходящие без изменений из исходных триангуляций, которые будем называть {\itshape лоскутами}.
Ребра и грани, не вошедшие в лоскуты, должны быть разрушены.
Такие связные подмножества будем называть {\itshape разрезами}.
При построении разрезов будут удалены некоторые грани, что приведет к образованию открытых ребер.
Связную цепочку вершин и открытых ребер, состоящих из ребер одного цвета, будем называть {\itshape краем}.
Максимальные связные подмножества разноцветных ребер и граней объединенной триангуляции будем называть {\itshape швами}.
Разноцветные ребра будем называть {\itshape стежками}.

При данных определениях построение объединенной триангуляции Делоне состоит из нескольких частей: построения разрезов,
выделения лоскутов исходных триангуляций и построения швов.
Каждый шов соединяет два разноцветных края, образованных после разрушения ребер, вошедших в разрезы.
В начале работы алгоритма краями исходных триангуляций являются их выпуклые оболочки.
По мере построения разрезов и швов количество краев меняется
(увеличивается при построении разрезов и уменьшается при построении швов).
В объединенной триангуляции остается только один край --- граница выпуклой оболочки.

{\itshape Стартером} будем называть пару разноцветных сайтов, образующих ребро Делоне,
еще не включенное в объединенную триангуляцию.
Стартер нужен для запуска процесса построения разрезов и швов.
Построение смежных стежков для стартера можно вести по разные стороны от него.
Для определенности будем полагать, что стартер имеет левый и правый сайты,
построение стежка происходит в направлении перед стартером.
На рис. \ref{pic:dir} черная жирная линия обозначает стартер, жирная пунктирная новый стежок, построенный в направлении перед стартером.

\begin{figure}[htb!]
	\begin{minipage}[h]{0.49\linewidth}
		\center{\includegraphics[width=0.7\linewidth]{starter.png}}
	\end{minipage}
	\hfill
	\begin{minipage}[h]{0.49\linewidth}
		\center{\includegraphics[width=0.7\linewidth]{direct_starter.png}}
	\end{minipage}
	\caption{Построение новых стежков}
	\label{pic:dir}
\end{figure}

Шов может быть двух типов.
{\itshape Разомкнутым} швом называется шов, имеющий два стежка, принадлежащих выпуклой оболочке объединенной триангуляции,
то есть принадлежащих граничным ребрам $Del(\textbf{B} \cup \textbf{W})$.
{\itshape Циклическим} называется шов, имеющий только внутренние ребра объединенной триангуляции.

В процессе построения разомкнутого шва сначала находим одну его часть,
затем продолжаем движение по другую сторону стартера и находим оставшуюся часть разреза.
В циклическом шве в некоторый момент времени стартер совпадет с новым стежком,
на этом построение шва будет закончено.

Введем понятие минимального остовного дерева.
{\itshape Минимальным остовным деревом (МОД)} триангуляции Делоне называется ее связный подграф,
имеющий наименьшую суммарную длину ребер.
Пусть на плоскости задано $N$ точек.
{\itshape Евклидовым МОД (ЕМОД)} называется связный подграф,
вершинами которого являются все $N$ точек, суммарная длина всех ребер которого минимальна.
Известно, что МОД ТД является евклидовым минимальным остовным деревом для множества сайтов ТД \cite[стр. 229, 277]{Preparata}.
МОД исходных триангуляций Делоне понадобятся в процессе построения стартеров.

Согласно определениям, данным выше, можно построить общую схему алгоритма слияния перекрывающихся триангуляций Делоне.

\begin{enumerate}
	\item Построить минимальные остовные деревья для обеих исходных триангуляций.
	\item Построить начальный стартер
	\item \label{alg:seam} Построить разрез и шов
	\begin{enumerate}
		\item Объявить стартер текущим стежком
		\item Провести коррекцию одноцветных ребер (построение разреза)
		\item \label{alg:stitch} Построить новый стежок
		\item Если построить новый стежок не удалось, развернуть стартер и перейти к пункту \ref{alg:seam}
		\item Если построить новый стежок не удалось во второй раз, закончить построение шва
		\item Удалить ребра, пересекающие новую грань
		\item Проверить совпадение со стартером, в случае совпадения закончить построение шва, иначе перейти к шагу \ref{alg:stitch}
	\end{enumerate}
	\item Поиск очередного стартера
	\item Если стартер найден, перейти к пункту \ref{alg:seam}, иначе закончить работу алгоритма
\end{enumerate}

\section{Описание алгоритма}
В данном разделе будет приведено подробное описание алгоритма слияния перекрывающихся триангуляций Делоне
на основе теоретического метода, описанного в \cite{MestOverlap}.

Пусть множество $\textbf{B}$ содержит $n_1$ точек c координатами
$(x_{11}, y_{11}), (x_{12}, y_{12}), \ldots, (x_{1n_1}, y_{1n_1})$,
множество $\textbf{W}$ --- $n_2$ точек с координатами
$(x_{21}, y_{21}), (x_{22}, y_{22}), \ldots, (x_{2n_2}, y_{2n_2})$.
На вход алгоритму подаются координаты первого и второго множества точек исходных триангуляций:
\begin{equation}\label{eq:points01}
\begin{split}
	points[0] = \{(x_{11}, y_{11}), (x_{12}, y_{12}), \ldots, (x_{1n_1}, y_{1n_1}) \} \\
	points[1] = \{(x_{21}, y_{21}), (x_{22}, y_{22}), \ldots, (x_{2n_2}, y_{2n_2}) \}
\end{split}
\end{equation}

Объединенное множество точек $\textbf{B} \cup \textbf{W}$,
содержащее $n = n_1 + n_2$ точек, будем обозначать:
\begin{equation}\label{eq:points2}
	points[2] = points[0] + points[1]\}
\end{equation}

На вход также подается некая структура данных, содержащая информацию о ребрах и/или гранях исходных триангуляций.
Выбор структуры данных сильно влияет на дальнейшую сложность вычислений.
Поэтому, рассмотрим более подробно этот пункт.

\subsection{Выбор структуры данных}
В книге \cite[стр. 11-17]{Skvortsov} описаны несколько структур данных,
которые могут быть использованы для решения поставленной задачи.

В нашей задаче будут часто производиться коррекции пучков сайтов,
поэтому операцию добавления и удаления ребер из пучка нужно производить очень эффективно.
В связи с этим требованием была выбрана структура данных {\itshape <<Узлы с соседями>>} (рис.\ref{pic:struct}).
Такая структура для каждого сайта хранит его координаты на плоскости и список номеров смежных сайтов в обходе против часовой стрелки.
Рассматриваемая структура данных неявно содержит ребра триангуляции, грани в данной структуре не хранятся вообще,
что в нашей задаче, вообще говоря, и не нужно.

\begin{figure}[htb!]
	\center{\includegraphics[width=0.5\linewidth]{struct.png}}
	\caption{Структура данных {\itshape <<Узлы с соседями>>}}
	\label{pic:struct}
\end{figure}

Для хранения описанной выше информации для каждого сайта создается двунаправленный список номеров смежных сайтов
в порядке обхода против часовой стрелки
в соответствии с их номером в объединенном множестве точек (\ref{eq:points2}):

\begin{equation}\label{eq:neib}
\begin{split}
	neighbors = \{list_1, list_2, \ldots, list_n\},
\end{split}
\end{equation}
где $list_i$ --- список смежных сайтов в порядке обхода против часовой стрелки для $i$-ого сайта.

Пусть сайт $A$ предшествует сайту $B$ в пучке сайта $C$, тогда верно:
\begin{equation}\label{eq:op}
\begin{split}
	A_{num} = neighbors[C_{num}].prev(B_{num}) \\
	B_{num} = neighbors[C_{num}].next(A_{num})
\end{split}
\end{equation}

\subsection{Построение разрезов и швов триангуляций Делоне}
Процесс построения разрезов и швов основан на проверке условия Делоне для ребер триангуляции,
которую можно осуществлять при помощи углового критерия \cite{MestOverlap} :

\begin{lemma}
\label{th:lem1}
Пусть $\textbf{S}$ --- множество сайтов, для пары $A, B \in \textbf{S}$ выполнено условие Делоне $\Leftrightarrow$
для любых других двух сайтов $C, D \in \textbf{S}$, лежащих по разные стороны от $AB$, справедливо:
$\angle ACB + \angle ADB \le 180^\circ$ и $\angle ABD \ge \angle ACD$
\end{lemma}

Пусть найдена разноцветная пара сайтов $A$ и $B$, такая что ребро $AB$ образует ребро Делоне в объединенной триангуляции,
ещё не включенное в нее.
Например, $AB$ является стартером.
Присоединение ребра $AB$ к пучкам сайтов-вершин $A$ и $B$ может привести к нарушению условия Делоне для некоторых ребер из этих пучков.
Все ребра, не удовлетворяющие условию Делоне, должны быть разрушены на этом этапе.
Рассмотрим, как вставляется ребро $AB$ в пучок сайта $A$.

\begin{figure}[htb!]
	\center{\includegraphics[width=0.4\linewidth]{deleteWrongEdges.png}}
	\caption{Коррекция одноцветных ребер}
	\label{pic:deleteWrongEdges}
\end{figure}

Пусть $AC_1$ и $AC_2$ одноцветные ребра пучка $A$,
что сайты $B$, $C_1$ и $C_2$ идут в порядке обхода против часовой стрелки в пучке сайта $A$ (рис. \ref{pic:deleteWrongEdges}).
Для ребра $AC_1$ нарушено условие Делоне, если $\angle AC_2C_1 + \angle ABC_1 > 180^\circ$.
В этом случае ребро $AC_1$ удаляется из объединенной триангуляции, а ребро $AC_2$ подвергается аналогичной проверке.
Если же для ребра $AC_1$ условие Делоне выполнено, то ребро $AC_1$ сохраняется в объединенной триангуляции,
проверка условия Делоне для остальных ребер не производится.

Аналогичным образом выполняется коррекция пучка сайта $A$
в направлении обхода по часовой стрелке.
После коррекции пучка сайта $A$ в обе стороны
ребро $AB$ разворачивается в противоположную сторону $BA$ и
осуществляется аналогичная проверка пучка сайта $B$ при добавлении в него сайта $A$.

Приведем формальное описание процедуры коррекции пучков сайтов (алгоритм \ref{alg:deleteWrongEdges}),
параметрами являются номера сайтов $A$ и $B$, для которых проводится коррекция.

\begin{algorithm}[htb!]
\floatname{algorithm}{Алгоритм}
\begin{algorithmic}[1]
\Procedure{deleteWrongeEdges$(a, b, reverse = 0)$}{}
	\While{True}
		\State $c_1 := neighbors[a].prev(b)$ // $c_1 := neighbors[a].next(b)$
		\State $c_2 := neighbors[a].prev(c_1)$ // $c_2 := neighbors[a].next(c_1)$
		\If{$\angle abc_1 + \angle ac_2c_1 \le 180^\circ$}
			\Break
		\Else
			\State Удалить ребро $ac_1$, продолжить коррекцию
		\EndIf
	\EndWhile
	\If{$reverse == 0$}
		\State deleteWrongeEdges$(b, a, 1)$
	\EndIf
\EndProcedure
\end{algorithmic}
\caption{Коррекция пучков сайтов}
\label{alg:deleteWrongEdges}
\end{algorithm}

Пучки, для которых выполнена описанная коррекция, будем называть {\itshape правильными}.
Рассмотрим процесс образования новых разноцветных ребер объединенной триангуляции Делоне (лемма \ref{th:lem2}, \cite{MestOverlap}):

\begin{lemma}
\label{th:lem2}
Пусть пучки сайтов $A$ и $B$ разноцветного ребра $AB$ являются правильными.
Точка $C$ следует за точкой в $B$ в пучке сайта $A$, точка $D$ предшествует точке $A$ в пучке сайта $B$,
тогда если $\angle ACB > \angle ADB$, то $CB$ является новым ребром Делоне, иначе $AD$ является новым ребром Делоне.
\end{lemma}

Лемма \ref{th:lem2} описывает процесс образования новых разноцветных стежков при построении шва.
Из начального стежка $AB$ получаем следующий стежок $AD$ или $CB$.
Основная сложность слияния неразделенных триангуляций состоит в том, что
новая грань может быть пересечена ребрами исходных триангуляций,
которые должны быть удалены во время построения очередного стежка.

\begin{figure}[htb!]
	\center{\includegraphics[width=0.3\linewidth]{triCorrection.png}}
	\caption{Пресечение ребер исходных триангуляций с новой гранью $\triangle ABD$}
	\label{pic:triCorrection}
\end{figure}

Пусть $AB$ --- текущее разноцветное ребро Делоне, не ограничивая общности будем считать,
что $AD$ --- новое разноцветное ребро (рис. \ref{pic:triCorrection}).

По лемме \ref{th:lem2} $AD$ не может иметь пересечений со старыми одноцветными ребрами из пучков сайтов $A$, $B$ и $D$.
Про два оставшихся ребра $AB$ и $BD$ так утверждать нельзя.
Действительно, все ребра в пучке $A$, лежащие между $AB$ и $AD$, обязательно пересекают одноцветное ребро $BD$,
по алгоритму построения ребра $AD$ все эти ребра не войдут в объединенную триангуляцию и должны быть разрушены.

Рассмотрим теперь пучок сайта $D$, в который включено вновь образованное ребро Делоне $AD$.
В этом пучке также могут найтись одноцветные ребра, лежащие между $DA$ и $DB$, которые пересекают ребро Делоне $AB$ и должны быть разрушены.
Поиск и разрушение указанных ребер осуществляется на основе последовательного просмотра пучка $A$ от $AB$ до $AD$ против часовой стрелки и пучка $D$ от $DA$ до $DB$ по часовой стрелке.

Таким образом, если найдено разноцветное ребро, удовлетворяющее условию Делоне,
то процесс построения разреза и шва можно проделывать рассмотренным способом.
Процедура, описывающая этот процесс, представлена в алгоритме \ref{alg:sewTriangle}.
На вход подаются номера точек $a$ и $b$, являющихся стартером.

\begin{algorithm}[htb!]
\floatname{algorithm}{Алгоритм}
\begin{algorithmic}[1]
\Procedure{sewTriangle$(starter, reverse = 0)$}{}
	\State $[a, b] := starter$
	\While{True}
		\State $deleteWrongEdges(a, b)$
		\State $c := neighbors[a].prev(b)$
		\State $d := neighbors[b].next(a)$
		\If{$(\angle acb > \angle adb~\&~\angle acb < \pi) \vee (\angle acb < \pi~\&~\angle adb \ge \pi)$}
			\State Добавить ребро $cb$ в триангуляцию \Comment{$cb$ является новым ребром}
			\State Удалить все ребра между $ca$ и $cb$ в обходе против часовой стрелки
			\State Удалить все ребра между $bc$ и $ba$ в обходе против часовой стрелки
			\If{$[c, b] \neq starter$}
				\State $a := c$
			\Else
				\State $reverse := 1$\Comment{Шов является циклическим}
				\Break
			\EndIf
		\ElsIf{$(\angle adb > \angle acb~\&~\angle adb < \pi) \vee (\angle adb < \pi~\&~\angle acb \ge \pi)$}
			\State $ad$ является новым ребром, аналогично ребру $cb$
		\Else
			\Break
		\EndIf
	\EndWhile
	\If{$reverse == 0$}
		\State sewTriangle$(b, a, 1)$
	\EndIf
\EndProcedure
\end{algorithmic}
\caption{Построение разреза и шва триангуляции}
\label{alg:sewTriangle}
\end{algorithm}

\subsection{Поиск стартеров}
В задаче поиска первого и последующих стартеров используется различная информация о триангуляциях.
Первый стартер ищется на основе начальной информации о триангуляциях,
в процессе поиска последующих используется информация о уже построенных швах и разрушенных при этом одноцветных ребер.

Рассмотрим условия существования стартеров (разноцветных ребер Делоне).
Лемма \ref{th:lem4} \cite{MestOverlap} заключает в себе основную идею построения стартеров,
поэтому приведем ее с доказательством.

\begin{figure}[htb!]
	\center{\includegraphics[width=0.4\linewidth]{starterLemma.png}}
	\caption{Условие существования стартера}
	\label{pic:starterLemma}
\end{figure}

\begin{lemma}
\label{th:lem4}
Сайт имеет инцидентное разноцветное ребро Делоне $\Leftrightarrow$ существует инцидентная ему окружность, внутри которой нет сайтов одного с ним цвета, но есть сайты противоположного цвета на ней или внутри нее.
\end{lemma}

\begin{proof}
Достаточность. Пусть для некоторого сайта $A$ существует инцидентная ему окружность с центром $C$,
внутри которой нет ни одного сайта того же цвета, что и $A$,
но есть сайты противоположного цвета $D_1, D_2, \ldots, D_k, k \ge 1$ другого цвета внутри или на окружности (рис. \ref{pic:starterLemma}).
Рассмотрим множество окружностей, инцидентных парам сайтов $A$ и $D_i, i = 1, \ldots, k$,
имеющих в точке $A$ общую касательную с окружностью с центром в точке $C$.
Окружность, имеющая минимальный радиус, является пустой, и она инцидентна разноцветной паре сайтов.
Значит, эта пара сайтов образует ребро Делоне и может являться стартером.

Необходимость. Есть пара сайтов, образующая ребро Делоне с инцидентной пустой окружностью.
Эта окружность и будет удовлетворять условию леммы.
\end{proof}

Согласно лемме \ref{th:lem4}, если существует сайт $A$ и инцидентная ему окружность $O$, удовлетворяющая условию леммы,
то поиск стартера сводится к перебору сайтов $D_1, D_2, \ldots, D_k, k \ge 1$, отличного от $A$ цвета,
внутри этой окружности и выбору сайта $D_{min}$,
такого что инцидентная $A$ и $D_{min}$ окружность имеет с окружностью $O$ общую касательную в точке $A$ и
минимальный радиус из всех таких окружностей, инцидентных $A$ и $D_i$.
Тогда ребро $AD_{min}$ можно использовать в качестве стартера.

\subsubsection{Поиск первого стартера}
Будем говорить, что сайт $A$ {\itshape лежит левее} сайта $B$,
если $A$ предшествует $B$ при лексикографическом упорядочивании сайтов по возрастанию координат $(x, y)$.

\begin{figure}[htb!]
	\center{\includegraphics[width=0.6\linewidth]{starterExample.png}}
	\caption{Поиск первого стартера}
	\label{pic:starterExample}
\end{figure}

Пусть $\textbf{B}$ и $\textbf{W}$ множества сайтов исходных триангуляций.
Найдем сайты $B_{min}$ и $W_{min}$, являющиеся самыми левыми в соответствующем множестве точек $\textbf{B}$ и $\textbf{W}$.
Не ограничивая общности, будем считать, что $B_{min}$ лежит левее, чем $W_{min}$  (рис. \ref{pic:starterExample}).
Рассмотрим окружность $O$, инцидентную сайтам $B_{min}$ и $W_{min}$ с центром на луче, параллельном оси $Ox$,
выходящим из точки $W_{min}$ влево.
Окружность $O$ не содержит ни одного сайта из $\textbf{W}$, потому что лежит левее самого левого сайта этого множества $W_{min}$,
и содержит сайт $B_{min}$ на границе окружности.
Возможно, ещё часть сайтов из $\textbf{B}$ попадет внутрь этой окружности.
Тогда точка $W_{min}$ и окружность $O$ удовлетворяют условиям леммы \ref{th:lem4}.
То есть первый стартер найден.
Алгоритм \ref{alg:findFirstStarter} описывает поиск первого стартера.

\begin{algorithm}[htb!]
\floatname{algorithm}{Алгоритм}
\begin{algorithmic}[1]
\Procedure{findFirstStarter()}{}
	\State $b$ --- самая левая точка множества $points[0]$
	\State $w$ --- самая левая точка множества $points[1]$
	\State $starter_{begin} := (b$ левее $w)~?~w~:~b$
	\State $num := (b$ левее $w)~?~0~:~1$
	\State $R_{min} := Inf$
	\For{$p \in points[num]$}
		\State $r$ --- радиус окружности с центром на луче из точки $w$ влево,
		инцидентной сайтам $p$ и $w$
		\If{$r < R_{min}$}
			\State $R_{min} := r$
			\State $starter_{end} := p$\Comment{Объявить $p$ концом стартера}
		\EndIf
	\EndFor
	\State \Return $[starter_{begin}, starter_{end}]$
\EndProcedure
\end{algorithmic}
\caption{Поиск первого стартера}
\label{alg:findFirstStarter}
\end{algorithm}

Время поиска первого стартера складывается из вычисления самых левых точек множеств $\textbf{B}$ и $\textbf{W}$ и
перебора точек из множества $\textbf{B}$ по алгоритму из леммы \ref{th:lem4},
то есть линейно по общему числу сайтов.

\subsubsection{Минимальные остовные деревья}
Задача поиска последующих стартеров основана на использовании минимальных остовных деревьев исходных триангуляций Делоне.
Теоретическая оценка трудоемкости задачи построения минимального остова составляет $О(n\log n)$.
В то же время известно, что на основе триангуляции Делоне ЕМОД может быть построен за линейное время (рис. \ref{pic:mst}).
Такой вычислительной сложностью обладает алгоритм Черитона-Тарьяна \cite[стр. 278-280]{Preparata},

\begin{figure}[htb!]
	\center{\includegraphics[width=0.5\linewidth]{mst.png}}
	\caption{Евклидово минимальное остовное дерево триангуляции Делоне}
	\label{pic:mst}
\end{figure}

Построение минимальных остовных деревьев осуществляется в процессе предобработки,
предшествующем непосредственному слиянию исходных триангуляций.
Рассмотрим подробнее алгоритм Черитона-Тарьяна.
{\itshape Лесом} называется упорядоченное множество деревьев.
На каждом шаге построения МОД алгоритм обрабатывает лес, содержащий несколько деревьев,
которые в ходе данного алгоритма станут поддеревьями искомого остовного дерева.
Сначала каждое дерево леса состоит из одной вершины триангуляции без ребер,
размер леса равен числу точек в триангуляции.
Для выбора дерева $T$ (которое будет объединено с другим деревом леса) они указали однородное правило выбора, перед использованием которого в очередь помещаются все деревья, содержащие по одной вершине.
\begin{enumerate}
	\item Выбрать дерево из начала очереди.
	\item Если дерево $T''$ получено в результате объединения дерева $T$ с некоторым другим деревом $T'$,
		то удалить $T$ и $T'$ из очереди и добавить $T''$ в конец очереди.
\end{enumerate}

Каждому дереву $T$ из очереди поставим в соответствие целое число, называемое {\itshape этапом} и вычисляемое следующим образом:
$stage(T) = 0$, если $|T| = 1$, и $stage(T)~=~\min(stage(T'),~stage(T''))~+~1$,
если $T$ является объединением деревьев $T'$ и $T''$.
В любой момент работы алгоритма последовательность чисел $stage(T)$ является неубывающей от начала к концу очереди.
Будем говорить, что этап $j$ завершен, если из очереди удалено дерево $T$,
для которого $stage(T) = j$, и ни для одного другого дерева $T$ в очереди значение $stage(T)$ не равно $j$.

Далее выбрав из очереди первый элемент $T$ ($stage(T) = j$), среди ребер,
соединяющих вершины дерева $T$ с вершинами вне его, ищем ребро наименьшей длины.
При такой организации обработки на каждом этапе каждое ребро просматривается не более двух раз
(кроме ребер, уже вошедших в некоторое дерево $T$).

Метод, позволяющий получить Евклидово МОД из триангуляции Делоне за линейное время,
использует операцию <<очистки>>, предложенную Черитоном и Тарьяном.
Цель операции очистки состоит в том, чтобы сжать исходный граф $G$ (граф триангуляции Делоне),
преобразовав его в некоторый граф $G^*$, который в любой момент работы алгоритма содержит лишь необходимую информацию.
Это означает, что каждое дерево $T$, входящее в лес $F$, сжимается в единственную вершину графа $G$
(т. е. удаляются все неотобранные ребра, соединяющие вершины дерева $T$) и
удаляются все ребра, за исключением самого короткого из неотобранных, соединяющие деревья $T'$ и $T''$.
Очистка графа производится сразу же после завершения этапа.
Предположим, что с каждым деревом $T$ связан список неотобранных ребер, инцидентных вершинам дерева $T$.
Формальное описание процедуры построения евклидова минимального остовного дерева описано в алгоритме \ref{alg:mst}.

\begin{algorithm}[htb!]
\floatname{algorithm}{Алгоритм}
\begin{algorithmic}[1]
\Procedure{makeMST()}{}
	\State $F := \emptyset$
	\For{$i := 1$ to $n$}
		\State $stage(points[2][i]) := 0$
		\State $F.insert(points[2][i])$
	\EndFor
	\State $j := 1$
	\While{$F \neq \emptyset$}
		\State $T' := F.get()$
		\If{$stage(T') == j$}
            \State Очистить граф
            \State $j := j + 1$
        \EndIf
        \State $(u, v)$ --- кратчайшее из неотобранных ребер, инцидентных $T'$ ($u \in T'$)
        \State $T'' := $ дерево в $F$, содержащее $v$
        \State $T := merge(T', T'')$
        \State Удалить $T''$ из $F$
        \State $stage(T) := \min(stage(T'),~stage(T'')) + 1$
        \State $F.insert(T)$
	\EndWhile
\EndProcedure
\end{algorithmic}
\caption{Построение ЕМОД по триангуляции Делоне}
\label{alg:mst}
\end{algorithm}

Поиск последующих стартеров основан на том, что при построении разреза в триангуляции Делоне нарушается ее связность,
при этом среди разрушенных ребер обязательно окажется ребро МОД этой триангуляции Делоне.

Будем называть окружность, диаметром которой является ребро МОД, {\itshape окружностью влияния ребра}.
Леммы \ref{th:lem5} и \ref{th:lem6} описывают свойства минимальных остовных деревьев,
которые понадобятся для теоретической оценки сложности алгоритма.

\begin{lemma}
\label{th:lem5}
Окружность влияния ребра МОД является пустой окружностью ТД.
\end{lemma}

\begin{lemma}
\label{th:lem6}
Расстояние между центрами двух ребер МОД не меньше, чем половина длины каждого ребра.
\end{lemma}

\subsubsection{Поиск последующих стартеров}
{\itshape Мостами} будем называть ребра исходных триангуляций,
входящие в МОД, разрушенные при построении очередного разреза.
Сайт, инцидентный мосту, называется {\itshape свободным}, если он имеет только одноцветные инцидентные ребра.
Сайт называется {\itshape закрепленным}, если он инцидентен мосту, но среди инцидентных ему ребер есть разноцветные.
Свободные сайты могут быть присоединены к объединенной триангуляции только при помощи построения новых швов,
поэтому существование свободного сайта говорит о том,
что построение объединенной триангуляции ещё не завершено:

\begin{lemma}
\label{th:lem7}
Существует стартер, инцидентный свободному сайту.
\end{lemma}

Пусть сайты $A$ и $B$ --- разноцветные, сайт $A$ входит в триангуляцию Делоне $T$.
{\itshape Максимальными пустыми окружностями} будем называть пустые окружности,
которые не содержатся внутри других пустых окружностей, не совпадающих с ними.
Рассмотрим множество окружностей, инцидентных $A$ и являющихся пустыми относительно сайтов триангуляции $T$.
В этом множестве существую максимальные пустые окружности, которые являются описанными окружностями граней триангуляции $T$,
инцидентные сайту $A$. 
В случае, когда $A$ принадлежит границе выпуклой оболочки триангуляции Делоне $T$,
несобственные окружности также будут максимальными пустыми окружностями, инцидентными сайту $A$.

\begin{lemma}
\label{th:lem8}
Пусть $AB$ --- стартер. Тогда сайт $B$ попадает внутрь хотя бы одной из максимальных пустых окружностей в $T$, инцидентных сайту $A$.
\end{lemma}

\begin{figure}[htb!]
	\center{\includegraphics[width=0.6\linewidth]{nextStarter.png}}
	\caption{Поиск последующих стартеров}
	\label{pic:nextStarter}
\end{figure}

Пусть $AB$ --- мост, сайт $A$ является закрепленным, сайт $B$ --- свободным (рис. \ref{pic:nextStarter}).
Сайты $A$ и $B$ имеют один и тот же цвет (на рисунке – черный) и в окружности влияния моста находятся лишь сайты противоположного цвета.
Согласно лемме \ref{th:lem7} свободный сайт $B$ может быть выбран в качестве первого сайта стартера.
Сайт $B$ попадает внутрь максимальных пустых окружностей триангуляции белых сайтов.
На рисунке это описанные окружности треугольных граней $\triangle C_3C_4C_5,~\triangle C_3C_5C_6,~\triangle C_6C_5C_7$.
Согласно лемме \ref{th:lem8} для нахождения второго сайта стартера можно выполнять перебор не по всем вершинам,
а только по вершинам граней, внутри описанных окружностей которых лежит сайт $B$.
Таким образом, поиск второго сайта осуществляется среди вершин этих граней,
причем только тех из них, которые попадают внутрь окружности влияния моста,
в нашем примере среди сайтов $C_3, C_4$ и $C_6$.

Сайт $A$ уже включен в объединенную триангуляцию,
поэтому можно оценить положение свободного сайта $B$ относительно этой триангуляции.
Сайт $B$ либо попадает внутрь какой-то грани, либо лежит вне выпуклой оболочки второй триангуляции.
В последнем случае можно найти ребро выпуклой оболочки, определяющее полуплоскость, в которой лежит $B$.
Задачу определения местоположения свободного сайта относительно триангуляции,
в которую уже включен закрепленный сайт, будем называть {\itshape локализацией моста}.
Рассмотрим множество ребер триангуляции, которые пересекает мост.
Эти ребра естественным образом упорядочиваются в направлении от закрепленного сайта к свободному.
Легко видеть, что последнее из пересекаемых мостом ребер либо инцидентно треугольной грани,
содержащей сайт $B$, либо определяет полуплоскость, содержащую $B$.
Найденная грань или полуплоскость есть решение задачи локализации моста.
Таким образом, задача локализации моста решается путем трассировки ребер и граней триангуляции вдоль моста.

Найденная грань имеет описанную окружность, которая содержит свободный сайт $B$.
Поиск остальных граней триангуляции, чьи описанные окружности содержат $B$,
осуществляется путем проверки смежных граней.
Объединением этих граней является многоугольник, содержащий сайт $B$.
В рассматриваемом примере это многоугольник $C_3C_4C_5C_7C_6$.
Среди вершин многоугольника обязательно найдутся сайты,
лежащие внутри окружности влияния моста (в противном случае мост не был бы разрушен).
Один из этих сайтов и образует стартер вместе с сайтом $B$.

Таким образом, поиск стартера на основе свободного сайта и инцидентного ему моста
может быть осуществлен алгоритмом \ref{alg:findNextStarter}:

\begin{algorithm}[htb!]
\floatname{algorithm}{Алгоритм}
\begin{algorithmic}[1]
\Procedure{findNextStarter$(bridge)$}{}
	\State $open$ --- открытый сайт ребра $bridge$
	\State Локализация $open$ относительно триангуляции, которой он не принадлежит
	\State $tempPoints$ --- множество сайтов, инцидентных грани, содержащей $open$
	\State $faces$ --- смежные грани триангуляции, в описанные окружности которых попадает сайт $open$
	\State Вершины, инцидентные граням из $faces$ добавляем в $tempPoints$
	\For{$p \in tempPoints$}
		\If{$p$ не попадает в окружность влияния $bridge$}
			\State Удалить $p$ из $tempPoints$
		\EndIf
	\EndFor
	\State $R_{min} := Inf$
	\State $starter_{end} := -1$
	\For{$p \in tempPoints$}
		\State $r$ --- радиус окружности с центром на $bridge$, инцидентной сайтам $p$ и $open$
		\If{$r < R_{min}$}
			\State $R_{min} := r$
			\State $starter_{end} := p$
		\EndIf
	\EndFor
	\Return $[open, starter_{end}]$
\EndProcedure
\end{algorithmic}
\caption{Поиск последующих стартеров}
\label{alg:findNextStarter}
\end{algorithm}

\subsection{Общая структура алгоритма}
В предыдущих пунктах был подробно описан каждый шаг алгоритма слияния перекрывающихся триангуляции.
Обобщим полученные результаты и напишем формальную процедуру слияния (алгоритм \ref{alg:makeConcatenation}).

\begin{algorithm}[htb!]
\floatname{algorithm}{Алгоритм}
\begin{algorithmic}[1]
\Procedure{makeConcatenation()}{}
	\State $makeMST()$
	\State $starter := findFirstStarter()$
	\State Добавить $starter$ в триангуляцию
	\State $bridges$ --- множество всех мостов, пополняется при построении разрезов и швов
	\State $sewTriangle(starter)$
	\While{$bridges \neq \emptyset$}
		\State $starter := findNextStarter(bridges.get())$
		\State Добавить $starter$ в триангуляцию
		\State $sewTriangle(starter)$
	\EndWhile
\EndProcedure
\end{algorithmic}
\caption{Слияние триангуляций}
\label{alg:makeConcatenation}
\end{algorithm}

\section{Оценка вычислительной сложности алгоритма}
Алгоритм слияния перекрывающихся триангуляций Делоне можно разделить на три части:
построение минимальных остовных деревьев исходных триангуляций Делоне,
поиск стартеров, построение разрезов и швов.
Алгоритм построения МОД Черитона-Тарьяна имеет сложность $O(n)$, что доказано в \cite{Preparata}.
Вычислительную сложность других частей алгоритма рассмотрим более подробно.

\subsection{Сложность поиска стартеров}
Пусть $n = |\textbf{B}| + |\textbf{W}|$ --- общее количество сайтов объединенной триангуляции.
Поиск первого стартера имеет сложность $O(n)$.
Поиск последующих стартеров включает в себя два перебора точек:
во-первых, это выбор моста –-- ребра МОД, разрушенного при разрезании триангуляций,
во-вторых, это пересечение мостом ребер триангуляции при локализации моста.
Можно построить примеры таких <<худших случаев>>, когда число мостов окажется $O(n)$ и
число ребер объединенной триангуляции, пересекающих отдельный мост, также $O(n)$.
Ниже будет показано, что общее число всех пересечений мостов и ребер исходных триангуляций все равно имеет сложность $O(n)$.

Рассмотрим процесс выбора очередного моста для трассировки.
Число ребер МОД равно $O(n)$.
При построении разрезов и швов все мосты заносятся в отдельный список.
Для дальнейшего поиска стартера выбирается любой мост, то есть это занимает времени $O(1)$.
В \cite{MestOverlap} доказано, что поиск последующих стартеров имеет сложность $O(n)$.
То есть общее время на поиск стартеров также равно $O(n)$.

\subsection{Сложность построения разрезов и швов}
На этом шаге алгоритма разрушаются одноцветные ребра,
которые перестали удовлетворять условию Делоне в объединенной триангуляции,
и строятся разноцветные ребра.
Построение нового ребра осуществляется на основе углового критерия (лемма \ref{th:lem1}) для пары конкурирующих ребер,
т.е. занимает фиксированное время $O(1)$.
Для каждого нового разноцветного ребра выполняется оценка корректности соседних с ним одноцветных ребер.
Такая проверка дважды запускает угловой критерий.
Если по результатам тестирования какое-то ребро уничтожается, то ставшее соседним другое одноцветное ребро вновь подвергается тесту.
Таким образом, время на удаление одного одноцветного ребра также оценивается как постоянное $O(1)$.

К общему времени стоит ещё добавить время включения нового ребра в триангуляцию.
При включении первого стежка, образуемого из стартера, может потребоваться полный перебор всех ребер, входящих в пучки двух инцидентных ему сайтов. Поэтому, общее время включения всех начальных ребер в пучки оценивается как $O(n)$.
А вот включение каждого очередного ребра уже не требует перебора ребер,
поскольку новое ребро устанавливается в пучок вслед за текущим анализируемым ребром.
Поэтому общее время на включение всех ребер есть $O(n)$.

Общее число построенных ребер не превосходит количество ребер в выходной триангуляции, то есть $O(n)$,
а общее число разрушенных ребер не превосходит общее число ребер в исходных триангуляциях --- тоже $O(n)$.

Таким образом, получили, что время построения разрезов и швов равно $O(n)$.
А, следовательно, и общее время работы алгоритма равно $O(n)$.

\section{Эксперименты}
В данном разделе будет описана программная реализация рассматриваемого алгоритма,
а также проведен ряд экспериментов по замеру времени работы алгоритма на входных данных разного размера.

\subsection{Программная реализация}
Для реализации алгоритма слияния перекрывающихся триангуляций Делоне был разработан класс
на языке программирования Python.
Данный класс имеет поля, хранящие для каждого сайта исходных триангуляций информацию о его координатах
и о упорядоченном списке инцидентных сайтов.
А также содержит все вышеописанные методы:
поиск первого стартера, реализация минимальных остовных деревьев по триангуляции Делоне,
построение разреза и шва от заданного стартера и поиск последующих стартеров.

Для тестирования программы можно использовать как автоматически сгенерированные облака точек исходных триангуляций,
так и введенные вручную точки.

\subsection{Вычислительный эксперимент}
Эксперимент проводился на данных разной размерности.
Случайным образом были сгенерированы множества точек для двух триангуляций:

$$n_1 = n_2 = [10 : 10 : 700]$$

В сравнение описанному линейному алгоритму ставился алгоритм <<разделяй и властвуй>>,
который строит триангуляцию Делоне на объединенном множестве точек,
не учитывающий информацию о исходных триангуляциях, и имеет сложность $O(n\log n)$.
График замера времени показан на рисунке \ref{pic:timeWork}.
Черной сплошной линией обозначено время работы линейного алгоритма,
пунктирной время работы алгоритма <<разделяй и властвуй>>.
По графику видно, что алгоритм слияния работает быстрее, чем построение триангуляции по объединенному множеству точек.

\begin{figure}[htb!]
	\center{\includegraphics[width=1\linewidth]{timeWork.png}}
	\caption{Время работы алгоритма слияния триангуляций}
	\label{pic:timeWork}
\end{figure}

Пример работы алгоритма представлен на рис. \ref{pic:exp_data}.
Как и требуется в алгоритме, в качестве исходных данных подаются две триангуляции,
результатом работы алгоритма является объединенная триангуляция.

\begin{figure}[htb!]
	\begin{minipage}[h]{1\linewidth}
		\center{\includegraphics[width=0.7\linewidth]{exp_data.png}}
	\end{minipage}
	\vfill
	\begin{minipage}[h]{1\linewidth}
		\center{\includegraphics[width=0.7\linewidth]{exp_res.png}}
	\end{minipage}
	\caption{Входные данные и результат слияния}
	\label{pic:exp_data}
\end{figure}

\section{Заключение}
В данной работе рассматривалась задача слияния двух перекрывающихся триангуляций Делоне
за линейное время. По теоретическому методу \cite{MestOverlap} был разработан алгоритм,
позволяющий решать данную задачу.
Проведенные вычислительные эксперименты подтвердили корректность и эффективность разработанного алгоритма.
Было выявлено, что слияние перекрывающихся триангуляций Делоне предпочтительнее
разрушения обеих триангуляций и построения искомой триангуляции по объединенному множеству точек.

Основным результатом данной работы является разработка структур данных и
алгоритма слияния линейно неразделимых триангуляций Делоне.

На защиту выносятся:

\begin{enumerate}
	\item Разработка структур данных
	\item Разработка алгоритма слияния перекрывающихся триангуляций Делоне за линейное время
	\item Программная реализация алгоритма
\end{enumerate}

\newpage

\addcontentsline{toc}{section}{Использованная литература}

\bibliographystyle{utf8gost705u}
\bibliography{report_diploma}
\end{document}